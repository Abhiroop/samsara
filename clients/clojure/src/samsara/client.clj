(ns samsara.client
  (:require [samsara.utils :refer [to-json]])
  (:require [taoensso.timbre :as log])
  (:require [org.httpkit.client :as http])
  (:require [samsara.ring-buffer :refer :all])
  (:require [schema.core :as s])
  (:require [chime :refer [chime-ch]]
            [clj-time.core :as t]
            [clj-time.periodic :refer [periodic-seq]]
            [clojure.core.async :as a :refer [<! go-loop]]))

;; Config
;; Map containing the following config:
;; :url - Samsara url
;; :publish-interval - how often should events be flushed to the api
;; :max-buffer-size - Max size of the ring buffer.
;; :sourceId is autogenerated for each client. [TODO: Currently just a randomUUID. Make this persistent.]
(def ^{:private true} samsara-config
  (atom {:url "http://samsara.io/v1"
         :sourceId (str (java.util.UUID/randomUUID))
         :publish-interval 3600 ;seconds
         :max-buffer-size 1500
         }))

(defn get-samsara-config [] @samsara-config)

(defn set-config! [config]
  "Set samsara configuration.
   The following properties can be set:
   :url - Samsara URL
   :sourceId - Unique ID for the client. This property is defaulted with an autogenerated value.
   :publish-interval - Frequency in seconds, in which the events will be flushed to samsara API.
   :max-buffer-size - Max size of the events ring buffer.

   NOTE: Changes to publish-interval and max-buffer-size properties will require a restart immediately
   after the first call to record-event"
  (swap! samsara-config into config))



(def single-event-schema
  "Schema validation for events"
  {
   (s/required-key :timestamp) s/Int
   (s/required-key :sourceId)  s/Str
   (s/required-key :eventName) s/Str
   s/Keyword s/Any})


;; this is the validation
;; for the entire payload
;; which it is just a composition of
;; other prismatic/schema (nice)
(def events-schema
  "Schema for a batch of events"
  [ single-event-schema ])


(defn- validate-event [events]
  "Validates the event [or the list of events]
    and throws an Exception if Invalid"
  (try
    (let [schema (if (map? events) single-event-schema events-schema)]
      (s/validate schema events))
    (catch clojure.lang.ExceptionInfo x
      ;; TODO: is this necessary? maybe we can just use the
      ;; prismatic/schema exception
      (throw (IllegalArgumentException. "Validation error" x)))))


(def ^{:private true} !event-headers! (atom {}))

(defn set-event-headers! [headers]
  "Set event headers"
  (swap! !event-headers! into headers))

(defn get-event-headers [] @!event-headers!)

(defn- enrich-event [event]
  "Enriches the event with default properties etc."
  (conj event (get-event-headers) {:timestamp (System/currentTimeMillis)
                                   :sourceId (@samsara-config :sourceId)}))

(defn- prepare-event [event]
  "Enriches and validates the event and throws an Exception if validation fails."
  (let [e (enrich-event event)]
    (validate-event e)
    e))

(defn- send-events [events]
  "Send events to samsara api"
  (let [{:keys [status error] :as resp} @(http/post (str ((get-samsara-config) :url) "/events")
                                                    {:timeout 500 ;;ms
                                                     :headers {"Content-Type" "application/json"
                                                               "X-Samsara-publishedTimestamp" (str (System/currentTimeMillis))}
                                                     :body (to-json events)})]
    ;;Throw the exception from HttpKit to the caller.
    (when error
      (log/error "Failed to connect to samsara with error: " error)
      (throw error))
    ;;Throw an exception if status is not 201.
    (when (not (= 202 status))
      (log/error "Publish failed with status:" status)
      (throw (RuntimeException. (str "PublishFailed with status=" status))))))


(defn publish-events [events]
  "Takes a vector containing events and publishes to samsara immediately."
  (validate-event events)
  (send-events events))


(def ^:private !buffer! (atom nil))


(defn- flush-buffer []
  "Flushes the event buffer to samsara api. Does nothing if another flush-buffer is in progress."
  (try
    (let [events (seq (snapshot @!buffer!))]
      (if (not (nil? events))
        (try
          (send-events (map second events))
          (dequeue! @!buffer! events)
          (catch Throwable t (log/error t "Flush failed. Leaving events in the buffer to try again.")))
        (log/info "Nothing to send.")))))

(defn- timer-flush []
  (log/warn "Timer is flushing now")
  (flush-buffer))

(defn !init! []
  "Initializes the ring buffer and the timer."
  (let [config (get-samsara-config)
        max-buffer-size (config :max-buffer-size)
        did-set (compare-and-set! !buffer! nil (ring-buffer max-buffer-size))
        publish-interval (config :publish-interval)
        times (periodic-seq (t/now) (-> publish-interval t/seconds))]

    (when did-set
      (log/info "Starting job to flush events.")
      (let [chimes (chime-ch times {:ch (a/chan (a/sliding-buffer 1))})]
        (go-loop []
          (when-let [time (<! chimes)]
            (log/info "Flushing buffer now.")
            (timer-flush)
            (recur)))))))


(defn record-event [event]
  "Buffers the events to be published later."
  (!init!) ;;Init if not initialised already
  (enqueue! @!buffer! (prepare-event event)))
